{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/utils/dateUtils.ts"],"sourcesContent":["import { StartOfYearDates } from '../../types/backtesting';\n\n/**\n * Date utilities for portfolio backtesting\n */\n\nexport const START_OF_YEAR_DATES: StartOfYearDates = {\n  '1996': '1996-01-02',\n  '1997': '1997-01-07', \n  '1998': '1998-01-06',\n  '1999': '1999-01-05',\n  '2000': '2000-01-04',\n  '2001': '2001-01-02',\n  '2002': '2002-01-02',\n  '2003': '2003-01-07',\n  '2004': '2004-01-06',\n  '2005': '2005-01-04',\n  '2006': '2006-01-03',\n  '2007': '2007-01-03',\n  '2008': '2008-01-02',\n  '2009': '2009-01-06',\n  '2010': '2010-01-05',\n  '2011': '2011-01-04',\n  '2012': '2012-01-03',\n  '2013': '2013-01-02',\n  '2014': '2014-01-07',\n  '2015': '2015-01-06',\n  '2016': '2016-01-05',\n  '2017': '2017-01-03',\n  '2018': '2018-01-02',\n  '2019': '2019-01-02',\n  '2020': '2020-01-07',\n  '2021': '2021-01-05',\n  '2022': '2022-01-04',\n  '2023': '2023-01-03',\n  '2024': '2024-01-02',\n  '2025': '2025-01-07'\n};\n\n/**\n * Get the start-of-year date for a given year\n */\nexport function getStartOfYearDate(year: number): string {\n  const yearStr = year.toString();\n  const date = START_OF_YEAR_DATES[yearStr];\n  if (!date) {\n    throw new Error(`No start-of-year date found for year ${year}`);\n  }\n  return date;\n}\n\n/**\n * Format date for API calls (YYYY-MM-DD)\n */\nexport function formatDateForAPI(date: string | Date): string {\n  if (typeof date === 'string') {\n    // Assume it's already in the correct format or convert from M/D/YY\n    if (date.includes('/')) {\n      const [month, day, year] = date.split('/');\n      const fullYear = parseInt(year) < 50 ? `20${year}` : `19${year}`;\n      return `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n    }\n    return date;\n  }\n  \n  return date.toISOString().split('T')[0];\n}\n\n/**\n * Parse date from various formats to Date object\n */\nexport function parseDate(dateStr: string): Date {\n  // Handle M/D/YY format\n  if (dateStr.includes('/')) {\n    const [month, day, year] = dateStr.split('/');\n    const fullYear = parseInt(year) < 50 ? `20${year}` : `19${year}`;\n    return new Date(`${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`);\n  }\n  \n  // Handle YYYY-MM-DD format\n  return new Date(dateStr);\n}\n\n/**\n * Check if a date is within a given range\n */\nexport function isDateInRange(date: string, startDate: string, endDate: string | null): boolean {\n  const checkDate = parseDate(date);\n  const rangeStart = parseDate(startDate);\n  \n  if (endDate) {\n    const rangeEnd = parseDate(endDate);\n    return checkDate >= rangeStart && checkDate <= rangeEnd;\n  }\n  \n  return checkDate >= rangeStart;\n}\n\n/**\n * Get all years in a range\n */\nexport function getYearsInRange(startYear: number, endYear: number): number[] {\n  const years: number[] = [];\n  for (let year = startYear; year <= endYear; year++) {\n    years.push(year);\n  }\n  return years;\n}\n\n/**\n * Calculate years between two dates\n */\nexport function getYearsBetweenDates(startDate: string, endDate: string): number {\n  const start = parseDate(startDate);\n  const end = parseDate(endDate);\n  return (end.getTime() - start.getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n}\n\n/**\n * Check if a year has a start date defined\n */\nexport function hasStartOfYearDate(year: number): boolean {\n  return START_OF_YEAR_DATES[year.toString()] !== undefined;\n}\n\n/**\n * Get the next valid year with a start date\n */\nexport function getNextValidYear(year: number): number | null {\n  for (let nextYear = year + 1; nextYear <= 2025; nextYear++) {\n    if (hasStartOfYearDate(nextYear)) {\n      return nextYear;\n    }\n  }\n  return null;\n}\n\n/**\n * Convert date to display format\n */\nexport function formatDateForDisplay(date: string): string {\n  const dateObj = parseDate(date);\n  return dateObj.toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  });\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/utils/portfolioUtils.ts"],"sourcesContent":["import { PortfolioHolding, PriceData, Stock } from '../../types/backtesting';\nimport { isDateInRange } from './dateUtils';\n\n/**\n * Portfolio utilities for backtesting strategies\n */\n\n/**\n * Get stocks available on a specific date\n */\nexport function getAvailableStocks(stocks: Stock[], date: string): Stock[] {\n  return stocks.filter(stock => isDateInRange(date, stock.startDate, stock.endDate));\n}\n\n/**\n * Calculate equal weights for a list of stocks\n */\nexport function calculateEqualWeights(stockCount: number): number[] {\n  const weight = 1 / stockCount;\n  return Array(stockCount).fill(weight);\n}\n\n/**\n * Calculate market cap weights from price data\n */\nexport function calculateMarketCapWeights(priceData: PriceData[]): number[] {\n  const totalMarketCap = priceData.reduce((sum, data) => sum + data.marketCap, 0);\n  \n  if (totalMarketCap === 0) {\n    return calculateEqualWeights(priceData.length);\n  }\n  \n  return priceData.map(data => data.marketCap / totalMarketCap);\n}\n\n/**\n * Calculate shares to purchase given dollar allocation and price\n */\nexport function calculateShares(dollarAmount: number, price: number): number {\n  if (price <= 0) return 0;\n  return Math.floor(dollarAmount / price);\n}\n\n/**\n * Calculate portfolio value from holdings and current prices\n */\nexport function calculatePortfolioValue(\n  holdings: PortfolioHolding[], \n  priceData: PriceData[]\n): number {\n  let totalValue = 0;\n  \n  holdings.forEach(holding => {\n    const currentPrice = priceData.find(p => p.ticker === holding.ticker);\n    if (currentPrice) {\n      totalValue += holding.shares * currentPrice.adjustedPrice;\n    }\n  });\n  \n  return totalValue;\n}\n\n/**\n * Update portfolio weights based on current values\n */\nexport function updatePortfolioWeights(\n  holdings: PortfolioHolding[], \n  totalValue: number\n): PortfolioHolding[] {\n  return holdings.map(holding => ({\n    ...holding,\n    weight: totalValue > 0 ? holding.value / totalValue : 0\n  }));\n}\n\n/**\n * Rebalance portfolio to target weights\n */\nexport function rebalancePortfolio(\n  currentHoldings: PortfolioHolding[],\n  targetWeights: number[],\n  availableStocks: Stock[],\n  priceData: PriceData[],\n  totalValue: number,\n  cash: number = 0\n): { holdings: PortfolioHolding[]; cash: number; trades: Trade[] } {\n  const trades: Trade[] = [];\n  const newHoldings: PortfolioHolding[] = [];\n  let remainingCash = cash;\n\n  // Calculate target dollar amounts\n  const totalToInvest = totalValue + cash;\n  \n  availableStocks.forEach((stock, index) => {\n    const targetWeight = targetWeights[index] || 0;\n    const targetValue = totalToInvest * targetWeight;\n    const currentPrice = priceData.find(p => p.ticker === stock.ticker);\n    \n    if (!currentPrice || currentPrice.adjustedPrice <= 0) {\n      return;\n    }\n\n    const currentHolding = currentHoldings.find(h => h.ticker === stock.ticker);\n    const currentValue = currentHolding ? currentHolding.value : 0;\n    const currentShares = currentHolding ? currentHolding.shares : 0;\n\n    // Calculate required shares for target value\n    const targetShares = Math.floor(targetValue / currentPrice.adjustedPrice);\n    const sharesDiff = targetShares - currentShares;\n\n    if (sharesDiff !== 0) {\n      const tradeValue = Math.abs(sharesDiff) * currentPrice.adjustedPrice;\n      \n      if (sharesDiff > 0) {\n        // Buy shares\n        if (remainingCash >= tradeValue) {\n          remainingCash -= tradeValue;\n          trades.push({\n            ticker: stock.ticker,\n            action: 'buy',\n            shares: sharesDiff,\n            price: currentPrice.adjustedPrice,\n            value: tradeValue\n          });\n        } else {\n          // Buy as many shares as possible with remaining cash\n          const affordableShares = Math.floor(remainingCash / currentPrice.adjustedPrice);\n          if (affordableShares > 0) {\n            const affordableValue = affordableShares * currentPrice.adjustedPrice;\n            remainingCash -= affordableValue;\n            trades.push({\n              ticker: stock.ticker,\n              action: 'buy',\n              shares: affordableShares,\n              price: currentPrice.adjustedPrice,\n              value: affordableValue\n            });\n          }\n        }\n      } else {\n        // Sell shares\n        remainingCash += tradeValue;\n        trades.push({\n          ticker: stock.ticker,\n          action: 'sell',\n          shares: Math.abs(sharesDiff),\n          price: currentPrice.adjustedPrice,\n          value: tradeValue\n        });\n      }\n    }\n\n    // Update holdings\n    const finalShares = currentShares + (sharesDiff > 0 ? \n      Math.min(sharesDiff, Math.floor(remainingCash / currentPrice.adjustedPrice)) : sharesDiff);\n    \n    if (finalShares > 0) {\n      newHoldings.push({\n        ticker: stock.ticker,\n        shares: finalShares,\n        value: finalShares * currentPrice.adjustedPrice,\n        weight: (finalShares * currentPrice.adjustedPrice) / totalToInvest,\n        marketCap: currentPrice.marketCap\n      });\n    }\n  });\n\n  return { holdings: newHoldings, cash: remainingCash, trades };\n}\n\n/**\n * Add new stocks to portfolio with proportional reduction\n */\nexport function addNewStocksProportionally(\n  currentHoldings: PortfolioHolding[],\n  newStocks: Stock[],\n  newStockWeights: number[],\n  priceData: PriceData[],\n  totalValue: number\n): PortfolioHolding[] {\n  const newHoldings = [...currentHoldings];\n  const totalNewWeight = newStockWeights.reduce((sum, weight) => sum + weight, 0);\n  const reductionFactor = 1 - totalNewWeight;\n\n  // Reduce existing holdings proportionally\n  newHoldings.forEach(holding => {\n    holding.weight *= reductionFactor;\n    holding.value = holding.weight * totalValue;\n  });\n\n  // Add new stocks\n  newStocks.forEach((stock, index) => {\n    const weight = newStockWeights[index];\n    const value = weight * totalValue;\n    const currentPrice = priceData.find(p => p.ticker === stock.ticker);\n    \n    if (currentPrice && currentPrice.adjustedPrice > 0) {\n      const shares = Math.floor(value / currentPrice.adjustedPrice);\n      if (shares > 0) {\n        newHoldings.push({\n          ticker: stock.ticker,\n          shares,\n          value: shares * currentPrice.adjustedPrice,\n          weight,\n          marketCap: currentPrice.marketCap\n        });\n      }\n    }\n  });\n\n  return newHoldings;\n}\n\n/**\n * Calculate annualized return\n */\nexport function calculateAnnualizedReturn(\n  startValue: number, \n  endValue: number, \n  years: number\n): number {\n  if (startValue <= 0 || years <= 0) return 0;\n  return Math.pow(endValue / startValue, 1 / years) - 1;\n}\n\n/**\n * Calculate total return\n */\nexport function calculateTotalReturn(startValue: number, endValue: number): number {\n  if (startValue <= 0) return 0;\n  return (endValue - startValue) / startValue;\n}\n\n/**\n * Format currency value\n */\nexport function formatCurrency(value: number): string {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  }).format(value);\n}\n\n/**\n * Format percentage\n */\nexport function formatPercentage(value: number, decimals: number = 2): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\n/**\n * Trade interface for tracking transactions\n */\nexport interface Trade {\n  ticker: string;\n  action: 'buy' | 'sell';\n  shares: number;\n  price: number;\n  value: number;\n}\n\n/**\n * Validate portfolio holdings\n */\nexport function validateHoldings(holdings: PortfolioHolding[]): boolean {\n  return holdings.every(holding => \n    holding.shares >= 0 && \n    holding.value >= 0 && \n    holding.weight >= 0 &&\n    holding.weight <= 1\n  );\n}\n\n/**\n * Clean up holdings (remove zero-share positions)\n */\nexport function cleanupHoldings(holdings: PortfolioHolding[]): PortfolioHolding[] {\n  return holdings.filter(holding => holding.shares > 0);\n}\n\n/**\n * Sort holdings by value (descending)\n */\nexport function sortHoldingsByValue(holdings: PortfolioHolding[]): PortfolioHolding[] {\n  return [...holdings].sort((a, b) => b.value - a.value);\n}\n\n/**\n * Get portfolio statistics\n */\nexport function getPortfolioStats(holdings: PortfolioHolding[]): {\n  totalValue: number;\n  stockCount: number;\n  largestHolding: PortfolioHolding | null;\n  topConcentration: number;\n} {\n  const totalValue = holdings.reduce((sum, holding) => sum + holding.value, 0);\n  const sortedHoldings = sortHoldingsByValue(holdings);\n  \n  return {\n    totalValue,\n    stockCount: holdings.length,\n    largestHolding: sortedHoldings[0] || null,\n    topConcentration: sortedHoldings[0]?.weight || 0\n  };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 390, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/strategies/equalWeightBuyHold.ts"],"sourcesContent":["import { \n  StrategyResult, \n  Stock, \n  PriceData, \n  PortfolioSnapshot, \n  PortfolioHolding \n} from '../../types/backtesting';\nimport { \n  getAvailableStocks, \n  calculateEqualWeights, \n  calculateShares,\n  calculatePortfolioValue,\n  calculateTotalReturn,\n  calculateAnnualizedReturn,\n  addNewStocksProportionally\n} from '../utils/portfolioUtils';\nimport { getStartOfYearDate, getYearsInRange, getYearsBetweenDates } from '../utils/dateUtils';\n\n/**\n * Equal Weight Buy and Hold Strategy\n * \n * Rules:\n * 1. Start with equal weight among all initially available stocks\n * 2. When new stocks become available at start of each year:\n *    - Calculate their equal weight allocation based on current portfolio size\n *    - Purchase the new stocks\n *    - Reduce existing holdings proportionally\n * 3. No rebalancing - just hold positions\n */\n\nexport async function runEqualWeightBuyHold(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number,\n  priceDataFetcher: (ticker: string, date: string) => Promise<PriceData | null>\n): Promise<StrategyResult> {\n  console.log('🔄 Running Equal Weight Buy & Hold Strategy...');\n  \n  const yearlySnapshots: PortfolioSnapshot[] = [];\n  let currentHoldings: PortfolioHolding[] = [];\n  let cash = 0;\n\n  // Initialize portfolio in start year\n  const startDate = getStartOfYearDate(startYear);\n  const initialStocks = getAvailableStocks(stocks, startDate);\n  \n  console.log(`📅 ${startYear}: Initializing with ${initialStocks.length} stocks`);\n  \n  // Get initial price data\n  const initialPriceData: PriceData[] = [];\n  for (const stock of initialStocks) {\n    const priceData = await priceDataFetcher(stock.ticker, startDate);\n    if (priceData) {\n      initialPriceData.push(priceData);\n    }\n  }\n\n  // Calculate equal weights and initial positions\n  const equalWeights = calculateEqualWeights(initialPriceData.length);\n  \n  initialPriceData.forEach((priceData, index) => {\n    const allocation = initialInvestment * equalWeights[index];\n    const shares = calculateShares(allocation, priceData.adjustedPrice);\n    const actualValue = shares * priceData.adjustedPrice;\n    \n    if (shares > 0) {\n      currentHoldings.push({\n        ticker: priceData.ticker,\n        shares,\n        value: actualValue,\n        weight: equalWeights[index],\n        marketCap: priceData.marketCap\n      });\n    }\n    \n    cash += allocation - actualValue; // Add leftover cash\n  });\n\n  // Record initial snapshot\n  const initialTotalValue = currentHoldings.reduce((sum, h) => sum + h.value, 0) + cash;\n  yearlySnapshots.push({\n    date: startDate,\n    totalValue: initialTotalValue,\n    holdings: [...currentHoldings],\n    cash\n  });\n\n  // Process each subsequent year\n  const yearsArray = getYearsInRange(startYear + 1, endYear);\n  \n  for (const year of yearsArray) {\n    console.log(`📅 ${year}: Processing year...`);\n    \n    const yearDate = getStartOfYearDate(year);\n    const availableStocks = getAvailableStocks(stocks, yearDate);\n    \n    // Get current prices for existing holdings\n    const currentPriceData: PriceData[] = [];\n    for (const holding of currentHoldings) {\n      const priceData = await priceDataFetcher(holding.ticker, yearDate);\n      if (priceData) {\n        currentPriceData.push(priceData);\n      }\n    }\n\n    // Update current portfolio value\n    currentHoldings = currentHoldings.map(holding => {\n      const currentPrice = currentPriceData.find(p => p.ticker === holding.ticker);\n      if (currentPrice) {\n        return {\n          ...holding,\n          value: holding.shares * currentPrice.adjustedPrice\n        };\n      }\n      return holding;\n    }).filter(holding => holding.value > 0); // Remove stocks that no longer have price data\n\n    const currentPortfolioValue = currentHoldings.reduce((sum, h) => sum + h.value, 0);\n    const totalValue = currentPortfolioValue + cash;\n\n    // Check for new stocks\n    const currentTickers = new Set(currentHoldings.map(h => h.ticker));\n    const newStocks = availableStocks.filter(stock => !currentTickers.has(stock.ticker));\n\n    if (newStocks.length > 0) {\n      console.log(`  📈 Adding ${newStocks.length} new stocks`);\n      \n      // Get price data for new stocks\n      const newStockPriceData: PriceData[] = [];\n      for (const stock of newStocks) {\n        const priceData = await priceDataFetcher(stock.ticker, yearDate);\n        if (priceData) {\n          newStockPriceData.push(priceData);\n        }\n      }\n\n      if (newStockPriceData.length > 0) {\n        // Calculate new allocation: equal weight for all stocks (existing + new)\n        const totalStockCount = currentHoldings.length + newStockPriceData.length;\n        const targetWeightPerStock = 1 / totalStockCount;\n        \n        // Calculate how much to allocate to new stocks\n        const newStockWeights = Array(newStockPriceData.length).fill(targetWeightPerStock);\n        \n        // Add new stocks with proportional reduction of existing holdings\n        const updatedHoldings = addNewStocksProportionally(\n          currentHoldings,\n          newStocks.slice(0, newStockPriceData.length),\n          newStockWeights,\n          newStockPriceData,\n          totalValue\n        );\n\n        // Execute trades to achieve new allocation\n        // Reduce existing positions proportionally\n        const reductionFactor = 1 - (newStockPriceData.length * targetWeightPerStock);\n        \n        currentHoldings.forEach(holding => {\n          const targetShares = Math.floor(holding.shares * reductionFactor);\n          const sharesToSell = holding.shares - targetShares;\n          \n          if (sharesToSell > 0) {\n            const currentPrice = currentPriceData.find(p => p.ticker === holding.ticker);\n            if (currentPrice) {\n              cash += sharesToSell * currentPrice.adjustedPrice;\n              holding.shares = targetShares;\n              holding.value = holding.shares * currentPrice.adjustedPrice;\n            }\n          }\n        });\n\n        // Buy new stocks\n        newStockPriceData.forEach((priceData, index) => {\n          const allocation = totalValue * targetWeightPerStock;\n          const shares = calculateShares(allocation, priceData.adjustedPrice);\n          const cost = shares * priceData.adjustedPrice;\n          \n          if (shares > 0 && cost <= cash) {\n            cash -= cost;\n            currentHoldings.push({\n              ticker: priceData.ticker,\n              shares,\n              value: cost,\n              weight: targetWeightPerStock,\n              marketCap: priceData.marketCap\n            });\n          }\n        });\n      }\n    }\n\n    // Update weights based on current values\n    const newTotalValue = currentHoldings.reduce((sum, h) => sum + h.value, 0) + cash;\n    currentHoldings = currentHoldings.map(holding => ({\n      ...holding,\n      weight: newTotalValue > 0 ? holding.value / newTotalValue : 0\n    }));\n\n    // Record yearly snapshot\n    yearlySnapshots.push({\n      date: yearDate,\n      totalValue: newTotalValue,\n      holdings: [...currentHoldings],\n      cash\n    });\n\n    console.log(`  💰 Portfolio value: $${newTotalValue.toLocaleString()}`);\n    console.log(`  📊 Holdings: ${currentHoldings.length} stocks`);\n  }\n\n  // Calculate final results\n  const startValue = yearlySnapshots[0].totalValue;\n  const endValue = yearlySnapshots[yearlySnapshots.length - 1].totalValue;\n  const totalReturn = calculateTotalReturn(startValue, endValue);\n  const yearCount = getYearsBetweenDates(\n    yearlySnapshots[0].date, \n    yearlySnapshots[yearlySnapshots.length - 1].date\n  );\n  const annualizedReturn = calculateAnnualizedReturn(startValue, endValue, yearCount);\n\n  console.log('✅ Equal Weight Buy & Hold Strategy completed');\n  console.log(`📈 Total Return: ${(totalReturn * 100).toFixed(2)}%`);\n  console.log(`📊 Annualized Return: ${(annualizedReturn * 100).toFixed(2)}%`);\n\n  return {\n    strategy: 'Equal Weight Buy & Hold',\n    startValue,\n    endValue,\n    totalReturn,\n    annualizedReturn,\n    yearlySnapshots\n  };\n}\n\n/**\n * Helper function to validate Equal Weight Buy & Hold strategy parameters\n */\nexport function validateEqualWeightBuyHoldParams(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number\n): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!stocks || stocks.length === 0) {\n    errors.push('No stocks provided');\n  }\n  \n  if (startYear >= endYear) {\n    errors.push('Start year must be before end year');\n  }\n  \n  if (initialInvestment <= 0) {\n    errors.push('Initial investment must be positive');\n  }\n  \n  if (stocks && stocks.length > 0) {\n    const startDate = getStartOfYearDate(startYear);\n    const initialStocks = getAvailableStocks(stocks, startDate);\n    \n    if (initialStocks.length === 0) {\n      errors.push(`No stocks available at start date (${startDate})`);\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Get strategy description\n */\nexport function getEqualWeightBuyHoldDescription(): string {\n  return `\n    Equal Weight Buy & Hold Strategy:\n    \n    1. Initially invests equal amounts in all available stocks\n    2. When new stocks join the index, allocates equal weight to them\n    3. Reduces existing holdings proportionally to make room for new stocks\n    4. No periodic rebalancing - positions grow/shrink with market movements\n    5. Maintains buy-and-hold approach throughout the investment period\n    \n    This strategy provides diversification benefits while minimizing transaction costs\n    by avoiding frequent rebalancing.\n  `;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 601, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/strategies/marketCapBuyHold.ts"],"sourcesContent":["import { \n  StrategyResult, \n  Stock, \n  PriceData, \n  PortfolioSnapshot, \n  PortfolioHolding \n} from '../../types/backtesting';\nimport { \n  getAvailableStocks, \n  calculateMarketCapWeights, \n  calculateShares,\n  calculateTotalReturn,\n  calculateAnnualizedReturn\n} from '../utils/portfolioUtils';\nimport { getStartOfYearDate, getYearsInRange, getYearsBetweenDates } from '../utils/dateUtils';\n\nexport async function runMarketCapBuyHold(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number,\n  priceDataFetcher: (ticker: string, date: string) => Promise<PriceData | null>\n): Promise<StrategyResult> {\n  console.log('🔄 Running Market Cap Weighted Buy & Hold Strategy...');\n  \n  const yearlySnapshots: PortfolioSnapshot[] = [];\n  let currentHoldings: PortfolioHolding[] = [];\n  let cash = 0;\n\n  // Initialize portfolio in start year\n  const startDate = getStartOfYearDate(startYear);\n  const initialStocks = getAvailableStocks(stocks, startDate);\n  \n  console.log(`📅 ${startYear}: Initializing with ${initialStocks.length} stocks`);\n  \n  // Get initial price data\n  const initialPriceData: PriceData[] = [];\n  for (const stock of initialStocks) {\n    const priceData = await priceDataFetcher(stock.ticker, startDate);\n    if (priceData) {\n      initialPriceData.push(priceData);\n    }\n  }\n\n  if (initialPriceData.length === 0) {\n    throw new Error('No price data available for initial stocks');\n  }\n\n  // Calculate market cap weights and initial positions\n  const marketCapWeights = calculateMarketCapWeights(initialPriceData);\n  \n  initialPriceData.forEach((priceData, index) => {\n    const allocation = initialInvestment * marketCapWeights[index];\n    const shares = calculateShares(allocation, priceData.adjustedPrice);\n    const actualValue = shares * priceData.adjustedPrice;\n    \n    if (shares > 0) {\n      currentHoldings.push({\n        ticker: priceData.ticker,\n        shares,\n        value: actualValue,\n        weight: marketCapWeights[index],\n        marketCap: priceData.marketCap\n      });\n    }\n    \n    cash += allocation - actualValue;\n  });\n\n  // Record initial snapshot\n  const initialTotalValue = currentHoldings.reduce((sum, h) => sum + h.value, 0) + cash;\n  yearlySnapshots.push({\n    date: startDate,\n    totalValue: initialTotalValue,\n    holdings: [...currentHoldings],\n    cash\n  });\n\n  console.log(`  💰 Initial portfolio value: $${initialTotalValue.toLocaleString()}`);\n\n  // Process each subsequent year\n  const subsequentYears = getYearsInRange(startYear + 1, endYear);\n  \n  for (const currentYear of subsequentYears) {\n    console.log(`📅 ${currentYear}: Processing year...`);\n    \n    const yearDate = getStartOfYearDate(currentYear);\n    const availableStocks = getAvailableStocks(stocks, yearDate);\n    \n    // Get current prices for existing holdings\n    const currentPriceData: PriceData[] = [];\n    for (const holding of currentHoldings) {\n      const priceData = await priceDataFetcher(holding.ticker, yearDate);\n      if (priceData) {\n        currentPriceData.push(priceData);\n      }\n    }\n\n    // Update current portfolio value with new prices\n    currentHoldings = currentHoldings.map(holding => {\n      const currentPrice = currentPriceData.find(p => p.ticker === holding.ticker);\n      if (currentPrice) {\n        return {\n          ...holding,\n          value: holding.shares * currentPrice.adjustedPrice,\n          marketCap: currentPrice.marketCap\n        };\n      }\n      return holding;\n    }).filter(holding => holding.value > 0);\n\n    const currentPortfolioValue = currentHoldings.reduce((sum, h) => sum + h.value, 0);\n    const totalValue = currentPortfolioValue + cash;\n\n    // Check for new stocks\n    const currentTickers = new Set(currentHoldings.map(h => h.ticker));\n    const newStocks = availableStocks.filter(stock => !currentTickers.has(stock.ticker));\n\n    if (newStocks.length > 0) {\n      console.log(`  📈 Adding ${newStocks.length} new stocks`);\n      \n      // Get price data for new stocks\n      const newStockPriceData: PriceData[] = [];\n      for (const stock of newStocks) {\n        const priceData = await priceDataFetcher(stock.ticker, yearDate);\n        if (priceData) {\n          newStockPriceData.push(priceData);\n        }\n      }\n\n      if (newStockPriceData.length > 0) {\n        // Calculate market cap weights for ALL stocks (existing + new)\n        const allPriceData = [...currentPriceData, ...newStockPriceData];\n        const allMarketCapWeights = calculateMarketCapWeights(allPriceData);\n        \n        // Determine weights for new stocks only\n        const newStockWeights = allMarketCapWeights.slice(currentPriceData.length);\n        const totalNewWeight = newStockWeights.reduce((sum, weight) => sum + weight, 0);\n        \n        let cashFromSales = 0;\n        currentHoldings.forEach((holding, index) => {\n          const newTargetWeight = allMarketCapWeights[index];\n          const currentWeight = holding.value / totalValue;\n          \n          if (newTargetWeight < currentWeight) {\n            const targetValue = totalValue * newTargetWeight;\n            const currentPrice = currentPriceData.find(p => p.ticker === holding.ticker);\n            \n            if (currentPrice) {\n              const targetShares = Math.floor(targetValue / currentPrice.adjustedPrice);\n              const sharesToSell = holding.shares - targetShares;\n              \n              if (sharesToSell > 0) {\n                cashFromSales += sharesToSell * currentPrice.adjustedPrice;\n                holding.shares = targetShares;\n                holding.value = holding.shares * currentPrice.adjustedPrice;\n                holding.weight = newTargetWeight;\n              }\n            }\n          }\n        });\n        \n        cash += cashFromSales;\n\n        // Buy new stocks according to their market cap weights\n        newStockPriceData.forEach((priceData, index) => {\n          const weight = newStockWeights[index];\n          const allocation = totalValue * weight;\n          const shares = calculateShares(allocation, priceData.adjustedPrice);\n          const cost = shares * priceData.adjustedPrice;\n          \n          if (shares > 0 && cost <= cash) {\n            cash -= cost;\n            currentHoldings.push({\n              ticker: priceData.ticker,\n              shares,\n              value: cost,\n              weight,\n              marketCap: priceData.marketCap\n            });\n          }\n        });\n      }\n    }\n\n    // Update weights based on current values\n    const newTotalValue = currentHoldings.reduce((sum, h) => sum + h.value, 0) + cash;\n    currentHoldings = currentHoldings.map(holding => ({\n      ...holding,\n      weight: newTotalValue > 0 ? holding.value / newTotalValue : 0\n    }));\n\n    // Record yearly snapshot\n    yearlySnapshots.push({\n      date: yearDate,\n      totalValue: newTotalValue,\n      holdings: [...currentHoldings],\n      cash\n    });\n\n    console.log(`  💰 Portfolio value: $${newTotalValue.toLocaleString()}`);\n    console.log(`  📊 Holdings: ${currentHoldings.length} stocks`);\n  }\n\n  // Calculate final results\n  const startValue = yearlySnapshots[0].totalValue;\n  const endValue = yearlySnapshots[yearlySnapshots.length - 1].totalValue;\n  const totalReturn = calculateTotalReturn(startValue, endValue);\n  const timeSpan = getYearsBetweenDates(\n    yearlySnapshots[0].date, \n    yearlySnapshots[yearlySnapshots.length - 1].date\n  );\n  const annualizedReturn = calculateAnnualizedReturn(startValue, endValue, timeSpan);\n\n  console.log('✅ Market Cap Weighted Buy & Hold Strategy completed');\n  console.log(`📈 Total Return: ${(totalReturn * 100).toFixed(2)}%`);\n  console.log(`📊 Annualized Return: ${(annualizedReturn * 100).toFixed(2)}%`);\n\n  return {\n    strategy: 'Market Cap Weighted Buy & Hold',\n    startValue,\n    endValue,\n    totalReturn,\n    annualizedReturn,\n    yearlySnapshots\n  };\n}\n\nexport function validateMarketCapBuyHoldParams(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number\n): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!stocks || stocks.length === 0) {\n    errors.push('No stocks provided');\n  }\n  \n  if (startYear >= endYear) {\n    errors.push('Start year must be before end year');\n  }\n  \n  if (initialInvestment <= 0) {\n    errors.push('Initial investment must be positive');\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 803, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/strategies/equalWeightRebalanced.ts"],"sourcesContent":["import { \n  StrategyResult, \n  Stock, \n  PriceData, \n  PortfolioSnapshot, \n  PortfolioHolding \n} from '../../types/backtesting';\nimport { \n  getAvailableStocks, \n  calculateEqualWeights, \n  calculateShares,\n  calculatePortfolioValue,\n  calculateTotalReturn,\n  calculateAnnualizedReturn\n} from '../utils/portfolioUtils';\nimport { getStartOfYearDate, getYearsInRange, getYearsBetweenDates } from '../utils/dateUtils';\n\n/**\n * Equal Weight Rebalanced Strategy\n * \n * Rules:\n * 1. Each year, rebalance the portfolio to equal weight across all available stocks\n * 2. Sell overweighted positions and buy underweighted ones\n * 3. New stocks entering the index get equal weight allocation\n * 4. Stocks leaving the index are sold\n * 5. Complete rebalancing at the start of each year\n */\n\nexport async function runEqualWeightRebalanced(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number,\n  priceDataFetcher: (ticker: string, date: string) => Promise<PriceData | null>\n): Promise<StrategyResult> {\n  console.log('🔄 Running Equal Weight Rebalanced Strategy...');\n  \n  const yearlySnapshots: PortfolioSnapshot[] = [];\n  let currentHoldings: PortfolioHolding[] = [];\n  let cash = initialInvestment;\n\n  // Process each year (including start year)\n  const yearsArray = getYearsInRange(startYear, endYear);\n  \n  for (const year of yearsArray) {\n    console.log(`📅 ${year}: Rebalancing portfolio...`);\n    \n    const yearDate = getStartOfYearDate(year);\n    const availableStocks = getAvailableStocks(stocks, yearDate);\n    \n    console.log(`  📊 Available stocks: ${availableStocks.length}`);\n    \n    if (availableStocks.length === 0) {\n      console.log(`  ⚠️  No stocks available in ${year}`);\n      continue;\n    }\n\n    // Get current prices for all available stocks\n    const currentPriceData: PriceData[] = [];\n    for (const stock of availableStocks) {\n      const priceData = await priceDataFetcher(stock.ticker, yearDate);\n      if (priceData) {\n        currentPriceData.push(priceData);\n      }\n    }\n\n    if (currentPriceData.length === 0) {\n      console.log(`  ❌ No price data available for ${year}`);\n      continue;\n    }\n\n    // Calculate current portfolio value\n    let currentPortfolioValue = 0;\n    if (currentHoldings.length > 0) {\n      currentPortfolioValue = calculatePortfolioValue(currentHoldings, currentPriceData);\n    }\n    \n    const totalValue = currentPortfolioValue + cash;\n    console.log(`  💰 Total value before rebalancing: $${totalValue.toLocaleString()}`);\n\n    // COMPLETE REBALANCING - Sell all positions first\n    if (currentHoldings.length > 0) {\n      console.log(`  🔄 Liquidating ${currentHoldings.length} existing positions`);\n      \n      // Sell all current holdings\n      for (const holding of currentHoldings) {\n        const currentPrice = currentPriceData.find(p => p.ticker === holding.ticker);\n        if (currentPrice) {\n          const saleValue = holding.shares * currentPrice.adjustedPrice;\n          cash += saleValue;\n          console.log(`    💸 Sold ${holding.shares} shares of ${holding.ticker} for $${saleValue.toLocaleString()}`);\n        }\n      }\n      \n      // Clear holdings\n      currentHoldings = [];\n    }\n\n    // Calculate equal weights for all available stocks\n    const equalWeights = calculateEqualWeights(currentPriceData.length);\n    const targetValuePerStock = cash / currentPriceData.length;\n    \n    console.log(`  🎯 Target allocation per stock: $${targetValuePerStock.toLocaleString()}`);\n\n    // Buy equal amounts of all available stocks\n    let totalSpent = 0;\n    currentPriceData.forEach((priceData, index) => {\n      const targetAllocation = cash * equalWeights[index];\n      const shares = calculateShares(targetAllocation, priceData.adjustedPrice);\n      const actualCost = shares * priceData.adjustedPrice;\n      \n      if (shares > 0) {\n        currentHoldings.push({\n          ticker: priceData.ticker,\n          shares,\n          value: actualCost,\n          weight: equalWeights[index],\n          marketCap: priceData.marketCap\n        });\n        \n        totalSpent += actualCost;\n        console.log(`    📈 Bought ${shares} shares of ${priceData.ticker} for $${actualCost.toLocaleString()}`);\n      }\n    });\n\n    // Update remaining cash\n    cash -= totalSpent;\n    \n    // Calculate final portfolio value\n    const finalPortfolioValue = currentHoldings.reduce((sum, h) => sum + h.value, 0);\n    const finalTotalValue = finalPortfolioValue + cash;\n\n    // Update weights based on actual values\n    currentHoldings = currentHoldings.map(holding => ({\n      ...holding,\n      weight: finalTotalValue > 0 ? holding.value / finalTotalValue : 0\n    }));\n\n    // Record yearly snapshot\n    yearlySnapshots.push({\n      date: yearDate,\n      totalValue: finalTotalValue,\n      holdings: [...currentHoldings],\n      cash\n    });\n\n    console.log(`  ✅ Rebalancing complete`);\n    console.log(`  💰 Final portfolio value: $${finalTotalValue.toLocaleString()}`);\n    console.log(`  💵 Remaining cash: $${cash.toLocaleString()}`);\n    console.log(`  📊 New holdings: ${currentHoldings.length} stocks at ${(100 / currentHoldings.length).toFixed(2)}% each`);\n    \n    // Validation check\n    const totalWeight = currentHoldings.reduce((sum, h) => sum + h.weight, 0);\n    if (Math.abs(totalWeight - 1) > 0.01 && currentHoldings.length > 0) {\n      console.log(`  ⚠️  Weight sum: ${(totalWeight * 100).toFixed(2)}% (expected 100%)`);\n    }\n  }\n\n  if (yearlySnapshots.length === 0) {\n    throw new Error('No valid snapshots created - check data availability');\n  }\n\n  // Calculate final results\n  const startValue = yearlySnapshots[0].totalValue;\n  const endValue = yearlySnapshots[yearlySnapshots.length - 1].totalValue;\n  const totalReturn = calculateTotalReturn(startValue, endValue);\n  const yearCount = getYearsBetweenDates(\n    yearlySnapshots[0].date, \n    yearlySnapshots[yearlySnapshots.length - 1].date\n  );\n  const annualizedReturn = calculateAnnualizedReturn(startValue, endValue, yearCount);\n\n  console.log('✅ Equal Weight Rebalanced Strategy completed');\n  console.log(`📈 Total Return: ${(totalReturn * 100).toFixed(2)}%`);\n  console.log(`📊 Annualized Return: ${(annualizedReturn * 100).toFixed(2)}%`);\n  console.log(`🔄 Total rebalancing events: ${yearlySnapshots.length}`);\n\n  return {\n    strategy: 'Equal Weight Rebalanced Annually',\n    startValue,\n    endValue,\n    totalReturn,\n    annualizedReturn,\n    yearlySnapshots\n  };\n}\n\n/**\n * Helper function to validate Equal Weight Rebalanced strategy parameters\n */\nexport function validateEqualWeightRebalancedParams(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number\n): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!stocks || stocks.length === 0) {\n    errors.push('No stocks provided');\n  }\n  \n  if (startYear >= endYear) {\n    errors.push('Start year must be before end year');\n  }\n  \n  if (initialInvestment <= 0) {\n    errors.push('Initial investment must be positive');\n  }\n  \n  if (stocks && stocks.length > 0) {\n    const startDate = getStartOfYearDate(startYear);\n    const initialStocks = getAvailableStocks(stocks, startDate);\n    \n    if (initialStocks.length === 0) {\n      errors.push(`No stocks available at start date (${startDate})`);\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Get strategy description\n */\nexport function getEqualWeightRebalancedDescription(): string {\n  return `\n    Equal Weight Rebalanced Annually Strategy:\n    \n    1. Each year, completely rebalances to equal weight across all available stocks\n    2. Sells all existing positions and redistributes capital equally\n    3. New stocks entering the index immediately get equal weight allocation\n    4. Stocks leaving the index are sold during rebalancing\n    5. Maintains precise equal weighting through annual rebalancing\n    6. Higher transaction costs due to frequent trading\n    \n    This strategy provides maximum diversification and ensures no single stock\n    dominates the portfolio, but generates more trading activity than buy-and-hold\n    approaches.\n  `;\n}\n\n/**\n * Calculate rebalancing statistics\n */\nexport function calculateRebalancingStats(snapshots: PortfolioSnapshot[]): {\n  totalRebalances: number;\n  averageStocksPerRebalance: number;\n  maxStocksInPortfolio: number;\n  minStocksInPortfolio: number;\n} {\n  const rebalances = snapshots.length;\n  const stockCounts = snapshots.map(s => s.holdings.length);\n  \n  return {\n    totalRebalances: rebalances,\n    averageStocksPerRebalance: stockCounts.reduce((sum, count) => sum + count, 0) / rebalances,\n    maxStocksInPortfolio: Math.max(...stockCounts),\n    minStocksInPortfolio: Math.min(...stockCounts)\n  };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/strategies/marketCapRebalanced.ts"],"sourcesContent":["import { \n  StrategyResult, \n  Stock, \n  PriceData, \n  PortfolioSnapshot, \n  PortfolioHolding \n} from '../../types/backtesting';\nimport { \n  getAvailableStocks, \n  calculateMarketCapWeights, \n  calculateShares,\n  calculatePortfolioValue,\n  calculateTotalReturn,\n  calculateAnnualizedReturn\n} from '../utils/portfolioUtils';\nimport { getStartOfYearDate, getYearsInRange, getYearsBetweenDates } from '../utils/dateUtils';\n\n/**\n * Market Cap Weighted Rebalanced Strategy\n * \n * Rules:\n * 1. Each year, rebalance the portfolio to market cap weights across all available stocks\n * 2. Sell overweighted positions and buy underweighted ones to match market cap ratios\n * 3. New stocks entering the index get market cap weighted allocation\n * 4. Stocks leaving the index are sold\n * 5. Complete rebalancing at the start of each year based on current market caps\n */\n\nexport async function runMarketCapRebalanced(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number,\n  priceDataFetcher: (ticker: string, date: string) => Promise<PriceData | null>\n): Promise<StrategyResult> {\n  console.log('🔄 Running Market Cap Weighted Rebalanced Strategy...');\n  \n  const yearlySnapshots: PortfolioSnapshot[] = [];\n  let currentHoldings: PortfolioHolding[] = [];\n  let cash = initialInvestment;\n\n  // Process each year (including start year)\n  const yearsArray = getYearsInRange(startYear, endYear);\n  \n  for (const year of yearsArray) {\n    console.log(`📅 ${year}: Rebalancing portfolio to market cap weights...`);\n    \n    const yearDate = getStartOfYearDate(year);\n    const availableStocks = getAvailableStocks(stocks, yearDate);\n    \n    console.log(`  📊 Available stocks: ${availableStocks.length}`);\n    \n    if (availableStocks.length === 0) {\n      console.log(`  ⚠️  No stocks available in ${year}`);\n      continue;\n    }\n\n    // Get current prices and market caps for all available stocks\n    const currentPriceData: PriceData[] = [];\n    for (const stock of availableStocks) {\n      const priceData = await priceDataFetcher(stock.ticker, yearDate);\n      if (priceData && priceData.marketCap > 0) { // Ensure we have valid market cap data\n        currentPriceData.push(priceData);\n      }\n    }\n\n    if (currentPriceData.length === 0) {\n      console.log(`  ❌ No valid price/market cap data available for ${year}`);\n      continue;\n    }\n\n    // Calculate current portfolio value\n    let currentPortfolioValue = 0;\n    if (currentHoldings.length > 0) {\n      currentPortfolioValue = calculatePortfolioValue(currentHoldings, currentPriceData);\n    }\n    \n    const totalValue = currentPortfolioValue + cash;\n    console.log(`  💰 Total value before rebalancing: $${totalValue.toLocaleString()}`);\n\n    // COMPLETE REBALANCING - Sell all positions first\n    if (currentHoldings.length > 0) {\n      console.log(`  🔄 Liquidating ${currentHoldings.length} existing positions`);\n      \n      // Sell all current holdings\n      for (const holding of currentHoldings) {\n        const currentPrice = currentPriceData.find(p => p.ticker === holding.ticker);\n        if (currentPrice) {\n          const saleValue = holding.shares * currentPrice.adjustedPrice;\n          cash += saleValue;\n          console.log(`    💸 Sold ${holding.shares} shares of ${holding.ticker} for $${saleValue.toLocaleString()}`);\n        } else {\n          // Stock was delisted or no longer available\n          console.log(`    ⚠️  ${holding.ticker} no longer available (delisted)`);\n        }\n      }\n      \n      // Clear holdings\n      currentHoldings = [];\n    }\n\n    // Calculate market cap weights\n    const marketCapWeights = calculateMarketCapWeights(currentPriceData);\n    \n    // Log market cap distribution for insight\n    const totalMarketCap = currentPriceData.reduce((sum, data) => sum + data.marketCap, 0);\n    console.log(`  📈 Total market cap: $${(totalMarketCap / 1e9).toFixed(1)}B`);\n    \n    // Show top 5 largest companies by market cap\n    const sortedByMarketCap = [...currentPriceData]\n      .sort((a, b) => b.marketCap - a.marketCap)\n      .slice(0, 5);\n    \n    console.log('  🏆 Top 5 companies by market cap:');\n    sortedByMarketCap.forEach((data, index) => {\n      const weight = data.marketCap / totalMarketCap;\n      console.log(`    ${index + 1}. ${data.ticker}: ${(weight * 100).toFixed(1)}% ($${(data.marketCap / 1e9).toFixed(1)}B)`);\n    });\n\n    // Buy stocks according to market cap weights\n    let totalSpent = 0;\n    currentPriceData.forEach((priceData, index) => {\n      const weight = marketCapWeights[index];\n      const targetAllocation = cash * weight;\n      const shares = calculateShares(targetAllocation, priceData.adjustedPrice);\n      const actualCost = shares * priceData.adjustedPrice;\n      \n      if (shares > 0) {\n        currentHoldings.push({\n          ticker: priceData.ticker,\n          shares,\n          value: actualCost,\n          weight,\n          marketCap: priceData.marketCap\n        });\n        \n        totalSpent += actualCost;\n        \n        // Only log significant positions (>0.1% weight) to avoid spam\n        if (weight > 0.001) {\n          console.log(`    📈 Bought ${shares} shares of ${priceData.ticker} (${(weight * 100).toFixed(2)}%) for $${actualCost.toLocaleString()}`);\n        }\n      }\n    });\n\n    // Update remaining cash\n    cash -= totalSpent;\n    \n    // Calculate final portfolio value\n    const finalPortfolioValue = currentHoldings.reduce((sum, h) => sum + h.value, 0);\n    const finalTotalValue = finalPortfolioValue + cash;\n\n    // Update weights based on actual values (should be very close to target weights)\n    currentHoldings = currentHoldings.map(holding => ({\n      ...holding,\n      weight: finalTotalValue > 0 ? holding.value / finalTotalValue : 0\n    }));\n\n    // Record yearly snapshot\n    yearlySnapshots.push({\n      date: yearDate,\n      totalValue: finalTotalValue,\n      holdings: [...currentHoldings],\n      cash\n    });\n\n    console.log(`  ✅ Rebalancing complete`);\n    console.log(`  💰 Final portfolio value: $${finalTotalValue.toLocaleString()}`);\n    console.log(`  💵 Remaining cash: $${cash.toLocaleString()} (${(cash / finalTotalValue * 100).toFixed(2)}%)`);\n    console.log(`  📊 New holdings: ${currentHoldings.length} stocks`);\n    \n    // Show concentration metrics\n    const topHoldings = [...currentHoldings]\n      .sort((a, b) => b.weight - a.weight)\n      .slice(0, 5);\n    \n    const top5Weight = topHoldings.reduce((sum, h) => sum + h.weight, 0);\n    const top10Weight = [...currentHoldings]\n      .sort((a, b) => b.weight - a.weight)\n      .slice(0, 10)\n      .reduce((sum, h) => sum + h.weight, 0);\n    \n    console.log(`  🎯 Top 5 holdings: ${(top5Weight * 100).toFixed(1)}% of portfolio`);\n    console.log(`  🎯 Top 10 holdings: ${(top10Weight * 100).toFixed(1)}% of portfolio`);\n    \n    // Validation check\n    const totalWeight = currentHoldings.reduce((sum, h) => sum + h.weight, 0);\n    if (Math.abs(totalWeight - 1) > 0.01 && currentHoldings.length > 0) {\n      console.log(`  ⚠️  Weight sum: ${(totalWeight * 100).toFixed(2)}% (expected ~100%)`);\n    }\n  }\n\n  if (yearlySnapshots.length === 0) {\n    throw new Error('No valid snapshots created - check data availability');\n  }\n\n  // Calculate final results\n  const startValue = yearlySnapshots[0].totalValue;\n  const endValue = yearlySnapshots[yearlySnapshots.length - 1].totalValue;\n  const totalReturn = calculateTotalReturn(startValue, endValue);\n  const yearCount = getYearsBetweenDates(\n    yearlySnapshots[0].date, \n    yearlySnapshots[yearlySnapshots.length - 1].date\n  );\n  const annualizedReturn = calculateAnnualizedReturn(startValue, endValue, yearCount);\n\n  console.log('✅ Market Cap Weighted Rebalanced Strategy completed');\n  console.log(`📈 Total Return: ${(totalReturn * 100).toFixed(2)}%`);\n  console.log(`📊 Annualized Return: ${(annualizedReturn * 100).toFixed(2)}%`);\n  console.log(`🔄 Total rebalancing events: ${yearlySnapshots.length}`);\n\n  return {\n    strategy: 'Market Cap Weighted Rebalanced Annually',\n    startValue,\n    endValue,\n    totalReturn,\n    annualizedReturn,\n    yearlySnapshots\n  };\n}\n\n/**\n * Helper function to validate Market Cap Rebalanced strategy parameters\n */\nexport function validateMarketCapRebalancedParams(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number\n): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!stocks || stocks.length === 0) {\n    errors.push('No stocks provided');\n  }\n  \n  if (startYear >= endYear) {\n    errors.push('Start year must be before end year');\n  }\n  \n  if (initialInvestment <= 0) {\n    errors.push('Initial investment must be positive');\n  }\n  \n  if (stocks && stocks.length > 0) {\n    const startDate = getStartOfYearDate(startYear);\n    const initialStocks = getAvailableStocks(stocks, startDate);\n    \n    if (initialStocks.length === 0) {\n      errors.push(`No stocks available at start date (${startDate})`);\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Get strategy description\n */\nexport function getMarketCapRebalancedDescription(): string {\n  return `\n    Market Cap Weighted Rebalanced Annually Strategy:\n    \n    1. Each year, completely rebalances to market cap weights across all available stocks\n    2. Larger companies receive proportionally larger allocations based on market cap\n    3. Sells all positions and redistributes capital according to current market caps\n    4. New stocks entering the index get market cap weighted allocation\n    5. Stocks leaving the index are sold during rebalancing\n    6. Maintains market consensus weighting through annual rebalancing\n    7. Higher transaction costs due to frequent trading\n    \n    This strategy follows institutional index fund approaches, concentrating in \n    larger companies while maintaining market-representative weightings through\n    periodic rebalancing.\n  `;\n}\n\n/**\n * Calculate concentration statistics for market cap weighted portfolios\n */\nexport function calculateConcentrationStats(snapshots: PortfolioSnapshot[]): {\n  averageTop5Concentration: number;\n  averageTop10Concentration: number;\n  maxSingleStockWeight: number;\n  averageNumberOfStocks: number;\n} {\n  const stats = snapshots.map(snapshot => {\n    const sortedHoldings = [...snapshot.holdings].sort((a, b) => b.weight - a.weight);\n    \n    const top5Weight = sortedHoldings.slice(0, 5).reduce((sum, h) => sum + h.weight, 0);\n    const top10Weight = sortedHoldings.slice(0, 10).reduce((sum, h) => sum + h.weight, 0);\n    const maxWeight = sortedHoldings[0]?.weight || 0;\n    \n    return {\n      top5Weight,\n      top10Weight,\n      maxWeight,\n      stockCount: snapshot.holdings.length\n    };\n  });\n  \n  const avgTop5 = stats.reduce((sum, s) => sum + s.top5Weight, 0) / stats.length;\n  const avgTop10 = stats.reduce((sum, s) => sum + s.top10Weight, 0) / stats.length;\n  const maxWeight = Math.max(...stats.map(s => s.maxWeight));\n  const avgStocks = stats.reduce((sum, s) => sum + s.stockCount, 0) / stats.length;\n  \n  return {\n    averageTop5Concentration: avgTop5,\n    averageTop10Concentration: avgTop10,\n    maxSingleStockWeight: maxWeight,\n    averageNumberOfStocks: avgStocks\n  };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1219, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/strategies/strategyRunner.ts"],"sourcesContent":["import { BacktestConfig, StrategyResult, PriceData, SPYData, Stock } from '../../types/backtesting';\nimport { runEqualWeightBuyHold } from './equalWeightBuyHold';\nimport { runMarketCapBuyHold } from './marketCapBuyHold';\nimport { runEqualWeightRebalanced } from './equalWeightRebalanced';\nimport { runMarketCapRebalanced } from './marketCapRebalanced';\nimport { calculateTotalReturn, calculateAnnualizedReturn } from '../utils/portfolioUtils';\nimport { getStartOfYearDate, getYearsBetweenDates } from '../utils/dateUtils';\n\n/**\n * Main strategy runner for portfolio backtesting\n * Orchestrates all four strategies and benchmarks against SPY\n */\n\nexport interface BacktestResults {\n  strategies: StrategyResult[];\n  spyBenchmark: {\n    startValue: number;\n    endValue: number;\n    totalReturn: number;\n    annualizedReturn: number;\n    data: SPYData[];\n  };\n  summary: {\n    bestStrategy: string;\n    worstStrategy: string;\n    spyOutperformers: string[];\n    executionTime: number;\n  };\n}\n\n/**\n * Run all backtesting strategies\n */\nexport async function runAllStrategies(\n  config: BacktestConfig,\n  priceDataFetcher: (ticker: string, date: string) => Promise<PriceData | null>,\n  spyDataFetcher: (startYear: number, endYear: number) => Promise<SPYData[]>\n): Promise<BacktestResults> {\n  console.log('🚀 Starting comprehensive portfolio backtest...');\n  console.log(`📅 Period: ${config.startYear} - ${config.endYear}`);\n  console.log(`💰 Initial Investment: $${config.initialInvestment.toLocaleString()}`);\n  console.log(`📊 Total Stocks: ${config.stocks.length}`);\n  \n  const startTime = Date.now();\n  const results: StrategyResult[] = [];\n\n  // Get SPY benchmark data\n  console.log('\\n📈 Fetching SPY benchmark data...');\n  const spyData = await spyDataFetcher(config.startYear, config.endYear);\n  \n  // Calculate SPY benchmark performance\n  const spyBenchmark = calculateSPYBenchmark(spyData, config.startYear, config.endYear, config.initialInvestment);\n  console.log(`📊 SPY Benchmark Return: ${(spyBenchmark.totalReturn * 100).toFixed(2)}%`);\n\n  // Define which strategies to run\n  const strategiesToRun = [\n    { name: 'Equal Weight Buy & Hold', enabled: config.strategies.includes('equalWeightBuyHold') },\n    { name: 'Market Cap Weighted Buy & Hold', enabled: config.strategies.includes('marketCapBuyHold') },\n    { name: 'Equal Weight Rebalanced Annually', enabled: config.strategies.includes('equalWeightRebalanced') },\n    { name: 'Market Cap Weighted Rebalanced Annually', enabled: config.strategies.includes('marketCapRebalanced') }\n  ];\n\n  const enabledStrategies = strategiesToRun.filter(s => s.enabled);\n  console.log(`\\n🎯 Running ${enabledStrategies.length} strategies...`);\n\n  // Run Equal Weight Buy & Hold\n  if (config.strategies.includes('equalWeightBuyHold')) {\n    console.log('\\n🔄 Running Strategy 1/4: Equal Weight Buy & Hold');\n    try {\n      const result = await runEqualWeightBuyHold(\n        config.stocks,\n        config.startYear,\n        config.endYear,\n        config.initialInvestment,\n        priceDataFetcher\n      );\n      results.push(result);\n      console.log(`✅ Completed - Return: ${(result.totalReturn * 100).toFixed(2)}%`);\n    } catch (error) {\n      console.error('❌ Equal Weight Buy & Hold failed:', error);\n    }\n  }\n\n  // Run Market Cap Weighted Buy & Hold\n  if (config.strategies.includes('marketCapBuyHold')) {\n    console.log('\\n🔄 Running Strategy 2/4: Market Cap Weighted Buy & Hold');\n    try {\n      const result = await runMarketCapBuyHold(\n        config.stocks,\n        config.startYear,\n        config.endYear,\n        config.initialInvestment,\n        priceDataFetcher\n      );\n      results.push(result);\n      console.log(`✅ Completed - Return: ${(result.totalReturn * 100).toFixed(2)}%`);\n    } catch (error) {\n      console.error('❌ Market Cap Weighted Buy & Hold failed:', error);\n    }\n  }\n\n  // Run Equal Weight Rebalanced\n  if (config.strategies.includes('equalWeightRebalanced')) {\n    console.log('\\n🔄 Running Strategy 3/4: Equal Weight Rebalanced Annually');\n    try {\n      const result = await runEqualWeightRebalanced(\n        config.stocks,\n        config.startYear,\n        config.endYear,\n        config.initialInvestment,\n        priceDataFetcher\n      );\n      results.push(result);\n      console.log(`✅ Completed - Return: ${(result.totalReturn * 100).toFixed(2)}%`);\n    } catch (error) {\n      console.error('❌ Equal Weight Rebalanced failed:', error);\n    }\n  }\n\n  // Run Market Cap Weighted Rebalanced\n  if (config.strategies.includes('marketCapRebalanced')) {\n    console.log('\\n🔄 Running Strategy 4/4: Market Cap Weighted Rebalanced Annually');\n    try {\n      const result = await runMarketCapRebalanced(\n        config.stocks,\n        config.startYear,\n        config.endYear,\n        config.initialInvestment,\n        priceDataFetcher\n      );\n      results.push(result);\n      console.log(`✅ Completed - Return: ${(result.totalReturn * 100).toFixed(2)}%`);\n    } catch (error) {\n      console.error('❌ Market Cap Weighted Rebalanced failed:', error);\n    }\n  }\n\n  // Calculate summary statistics\n  const executionTime = Date.now() - startTime;\n  const summary = calculateSummary(results, spyBenchmark, executionTime);\n\n  console.log('\\n🎉 Backtest Complete!');\n  console.log('='.repeat(50));\n  console.log('📊 RESULTS SUMMARY');\n  console.log('='.repeat(50));\n  \n  // Display results table\n  console.log('\\nStrategy Performance:');\n  console.log('Strategy'.padEnd(35) + 'Total Return'.padEnd(15) + 'Annual Return'.padEnd(15) + 'Final Value');\n  console.log('-'.repeat(80));\n  \n  results.forEach(result => {\n    const totalRet = `${(result.totalReturn * 100).toFixed(2)}%`;\n    const annualRet = `${(result.annualizedReturn * 100).toFixed(2)}%`;\n    const finalVal = `$${result.endValue.toLocaleString()}`;\n    \n    console.log(\n      result.strategy.padEnd(35) + \n      totalRet.padEnd(15) + \n      annualRet.padEnd(15) + \n      finalVal\n    );\n  });\n  \n  // SPY Benchmark\n  const spyTotalRet = `${(spyBenchmark.totalReturn * 100).toFixed(2)}%`;\n  const spyAnnualRet = `${(spyBenchmark.annualizedReturn * 100).toFixed(2)}%`;\n  const spyFinalVal = `$${spyBenchmark.endValue.toLocaleString()}`;\n  \n  console.log('-'.repeat(80));\n  console.log(\n    'SPY Benchmark'.padEnd(35) + \n    spyTotalRet.padEnd(15) + \n    spyAnnualRet.padEnd(15) + \n    spyFinalVal\n  );\n\n  console.log(`\\n🏆 Best Strategy: ${summary.bestStrategy}`);\n  console.log(`📉 Worst Strategy: ${summary.worstStrategy}`);\n  console.log(`🎯 Strategies beating SPY: ${summary.spyOutperformers.length > 0 ? summary.spyOutperformers.join(', ') : 'None'}`);\n  console.log(`⏱️  Execution Time: ${(executionTime / 1000).toFixed(1)} seconds`);\n\n  return {\n    strategies: results,\n    spyBenchmark,\n    summary\n  };\n}\n\n/**\n * Calculate SPY benchmark performance\n */\nfunction calculateSPYBenchmark(\n  spyData: SPYData[], \n  startYear: number, \n  endYear: number, \n  initialInvestment: number\n): {\n  startValue: number;\n  endValue: number;\n  totalReturn: number;\n  annualizedReturn: number;\n  data: SPYData[];\n} {\n  if (spyData.length === 0) {\n    throw new Error('No SPY data available for benchmark');\n  }\n\n  // Find start and end data points\n  const startDate = getStartOfYearDate(startYear);\n  const endDate = getStartOfYearDate(endYear);\n  \n  const startPoint = spyData.find(d => d.date >= startDate) || spyData[0];\n  const endPoint = spyData[spyData.length - 1];\n\n  // Calculate SPY returns\n  const sharesOwned = initialInvestment / startPoint.adjustedPrice;\n  const endValue = sharesOwned * endPoint.adjustedPrice;\n  const totalReturn = calculateTotalReturn(initialInvestment, endValue);\n  \n  const years = getYearsBetweenDates(startPoint.date, endPoint.date);\n  const annualizedReturn = calculateAnnualizedReturn(initialInvestment, endValue, years);\n\n  return {\n    startValue: initialInvestment,\n    endValue,\n    totalReturn,\n    annualizedReturn,\n    data: spyData\n  };\n}\n\n/**\n * Calculate summary statistics\n */\nfunction calculateSummary(\n  results: StrategyResult[], \n  spyBenchmark: any, \n  executionTime: number\n): {\n  bestStrategy: string;\n  worstStrategy: string;\n  spyOutperformers: string[];\n  executionTime: number;\n} {\n  if (results.length === 0) {\n    return {\n      bestStrategy: 'None',\n      worstStrategy: 'None',\n      spyOutperformers: [],\n      executionTime\n    };\n  }\n\n  // Find best and worst strategies\n  const bestStrategy = results.reduce((best, current) => \n    current.endValue > best.endValue ? current : best\n  );\n  \n  const worstStrategy = results.reduce((worst, current) => \n    current.endValue < worst.endValue ? current : worst\n  );\n\n  // Find strategies that beat SPY\n  const spyOutperformers = results\n    .filter(result => result.endValue > spyBenchmark.endValue)\n    .map(result => result.strategy);\n\n  return {\n    bestStrategy: bestStrategy.strategy,\n    worstStrategy: worstStrategy.strategy,\n    spyOutperformers,\n    executionTime\n  };\n}\n\n/**\n * Validate backtest configuration\n */\nexport function validateBacktestConfig(config: BacktestConfig): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!config.stocks || config.stocks.length === 0) {\n    errors.push('No stocks provided in configuration');\n  }\n\n  if (config.startYear >= config.endYear) {\n    errors.push('Start year must be before end year');\n  }\n\n  if (config.startYear < 1996 || config.endYear > 2025) {\n    errors.push('Years must be between 1996 and 2025');\n  }\n\n  if (config.initialInvestment <= 0) {\n    errors.push('Initial investment must be positive');\n  }\n\n  if (!config.strategies || config.strategies.length === 0) {\n    errors.push('No strategies selected');\n  }\n\n  const validStrategies = [\n    'equalWeightBuyHold',\n    'marketCapBuyHold', \n    'equalWeightRebalanced',\n    'marketCapRebalanced'\n  ];\n\n  const invalidStrategies = config.strategies.filter(s => !validStrategies.includes(s));\n  if (invalidStrategies.length > 0) {\n    errors.push(`Invalid strategies: ${invalidStrategies.join(', ')}`);\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Get list of available strategies\n */\nexport function getAvailableStrategies(): Array<{ id: string; name: string; description: string }> {\n  return [\n    {\n      id: 'equalWeightBuyHold',\n      name: 'Equal Weight Buy & Hold',\n      description: 'Start with equal weights, add new stocks proportionally, no rebalancing'\n    },\n    {\n      id: 'marketCapBuyHold',\n      name: 'Market Cap Weighted Buy & Hold', \n      description: 'Start with market cap weights, add new stocks by market cap, no rebalancing'\n    },\n    {\n      id: 'equalWeightRebalanced',\n      name: 'Equal Weight Rebalanced Annually',\n      description: 'Rebalance to equal weights across all stocks each year'\n    },\n    {\n      id: 'marketCapRebalanced',\n      name: 'Market Cap Weighted Rebalanced Annually',\n      description: 'Rebalance to market cap weights across all stocks each year'\n    }\n  ];\n}\n\n/**\n * Create backtest configuration from user inputs\n */\nexport function createBacktestConfig(\n  stocks: Stock[],\n  startYear: number,\n  endYear: number,\n  initialInvestment: number = 1000000,\n  strategies: string[] = ['equalWeightBuyHold', 'marketCapBuyHold', 'equalWeightRebalanced', 'marketCapRebalanced']\n): BacktestConfig {\n  return {\n    stocks,\n    startYear,\n    endYear,\n    initialInvestment,\n    strategies\n  };\n}\n\n/**\n * Format results for display\n */\nexport function formatResults(results: BacktestResults): string {\n  let output = 'Portfolio Backtesting Results\\n';\n  output += '='.repeat(50) + '\\n\\n';\n  \n  results.strategies.forEach(strategy => {\n    output += `${strategy.strategy}:\\n`;\n    output += `  Final Value: $${strategy.endValue.toLocaleString()}\\n`;\n    output += `  Total Return: ${(strategy.totalReturn * 100).toFixed(2)}%\\n`;\n    output += `  Annualized Return: ${(strategy.annualizedReturn * 100).toFixed(2)}%\\n\\n`;\n  });\n  \n  output += `SPY Benchmark:\\n`;\n  output += `  Final Value: $${results.spyBenchmark.endValue.toLocaleString()}\\n`;\n  output += `  Total Return: ${(results.spyBenchmark.totalReturn * 100).toFixed(2)}%\\n`;\n  output += `  Annualized Return: ${(results.spyBenchmark.annualizedReturn * 100).toFixed(2)}%\\n\\n`;\n  \n  output += `Best Strategy: ${results.summary.bestStrategy}\\n`;\n  output += `Strategies beating SPY: ${results.summary.spyOutperformers.join(', ')}\\n`;\n  \n  return output;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1512, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/app/api/backtesting/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { BacktestConfig, runAllStrategies, validateBacktestConfig } from '../../../lib/strategies/strategyRunner';\nimport { PriceData, SPYData, Stock } from '../../../types/backtesting';\n\n// Rate limiting configuration\nconst RATE_LIMIT_DELAY = parseInt(process.env.BACKTEST_RATE_LIMIT_MS || '100');\nconst MAX_CONCURRENT_REQUESTS = parseInt(process.env.BACKTEST_MAX_CONCURRENT_REQUESTS || '5');\n\n/**\n * Main backtesting API endpoint\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const config: BacktestConfig = await request.json();\n    \n    // Validate configuration\n    const validation = validateBacktestConfig(config);\n    if (!validation.isValid) {\n      return NextResponse.json(\n        { error: 'Invalid configuration', details: validation.errors },\n        { status: 400 }\n      );\n    }\n\n    console.log('🚀 Starting backtest API request...');\n    console.log(`📅 Period: ${config.startYear} - ${config.endYear}`);\n    console.log(`📊 Strategies: ${config.strategies.join(', ')}`);\n    console.log(`💰 Initial Investment: $${config.initialInvestment.toLocaleString()}`);\n\n    // Create a streaming response\n    const stream = new ReadableStream({\n      async start(controller) {\n        const encoder = new TextEncoder();\n        \n        const sendProgress = (current: number, total: number, step: string) => {\n          const progress = { type: 'progress', progress: { current, total, step } };\n          controller.enqueue(encoder.encode(JSON.stringify(progress) + '\\n'));\n        };\n\n        const sendError = (error: string) => {\n          const errorMsg = { type: 'error', error };\n          controller.enqueue(encoder.encode(JSON.stringify(errorMsg) + '\\n'));\n          controller.close();\n        };\n\n        const sendResults = (results: any) => {\n          const resultsMsg = { type: 'results', results };\n          controller.enqueue(encoder.encode(JSON.stringify(resultsMsg) + '\\n'));\n          controller.close();\n        };\n\n        try {\n          // Initialize progress\n          sendProgress(1, 10, 'Initializing backtesting environment...');\n\n          // Create price data fetcher with rate limiting\n          let requestCount = 0;\n          const priceDataFetcher = async (ticker: string, date: string): Promise<PriceData | null> => {\n            try {\n              requestCount++;\n              if (requestCount % 10 === 0) {\n                sendProgress(\n                  Math.min(2 + Math.floor(requestCount / 100), 8), \n                  10, \n                  `Fetching price data... (${requestCount} requests)`\n                );\n              }\n\n              // Add rate limiting delay\n              if (RATE_LIMIT_DELAY > 0) {\n                await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));\n              }\n\n              const response = await fetch(\n                `${request.nextUrl.origin}/api/market-cap?ticker=${ticker}&date=${date}`,\n                { \n                  method: 'GET',\n                  headers: { 'User-Agent': 'Backtesting-Service/1.0' }\n                }\n              );\n\n              if (!response.ok) {\n                console.warn(`Failed to fetch data for ${ticker} on ${date}: ${response.status}`);\n                return null;\n              }\n\n              const data = await response.json();\n              \n              if (!data.price || !data.shares_outstanding) {\n                console.warn(`Incomplete data for ${ticker} on ${date}`);\n                return null;\n              }\n\n              return {\n                ticker: data.ticker,\n                date: data.date,\n                price: data.price,\n                adjustedPrice: data.adjusted_price || data.price,\n                sharesOutstanding: data.shares_outstanding,\n                marketCap: data.market_cap || (data.price * data.shares_outstanding)\n              };\n            } catch (error) {\n              console.error(`Error fetching data for ${ticker} on ${date}:`, error);\n              return null;\n            }\n          };\n\n          // Create SPY data fetcher\n          const spyDataFetcher = async (startYear: number, endYear: number): Promise<SPYData[]> => {\n            sendProgress(3, 10, 'Fetching SPY benchmark data...');\n            \n            try {\n              const response = await fetch(\n                `${request.nextUrl.origin}/api/spy-data?startYear=${startYear}&endYear=${endYear}`\n              );\n              \n              if (!response.ok) {\n                throw new Error(`SPY data fetch failed: ${response.status}`);\n              }\n              \n              const data = await response.json();\n              return data.spyData || [];\n            } catch (error) {\n              console.error('Error fetching SPY data:', error);\n              throw new Error('Failed to fetch SPY benchmark data');\n            }\n          };\n\n          sendProgress(4, 10, 'Starting strategy execution...');\n\n          // Run all strategies\n          const results = await runAllStrategies(\n            config,\n            priceDataFetcher,\n            spyDataFetcher\n          );\n\n          sendProgress(10, 10, 'Backtest completed successfully!');\n          \n          // Send final results\n          sendResults(results);\n\n        } catch (error) {\n          console.error('Backtest execution failed:', error);\n          sendError(error instanceof Error ? error.message : 'Unknown error occurred');\n        }\n      }\n    });\n\n    return new Response(stream, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Cache-Control': 'no-cache',\n        'Connection': 'keep-alive',\n      },\n    });\n\n  } catch (error) {\n    console.error('Backtesting API error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Get S&P 500 historical constituents\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const action = searchParams.get('action');\n\n    if (action === 'sp500-stocks') {\n      // Load S&P 500 historical data from CSV\n      const fs = require('fs');\n      const path = require('path');\n      const Papa = require('papaparse');\n\n      const csvPath = path.join(process.cwd(), 'data', 'sp500-tickers.csv');\n      \n      if (!fs.existsSync(csvPath)) {\n        return NextResponse.json(\n          { error: 'S&P 500 data file not found' },\n          { status: 404 }\n        );\n      }\n\n      const csvContent = fs.readFileSync(csvPath, 'utf8');\n      const parsed = Papa.parse(csvContent, {\n        header: true,\n        dynamicTyping: true,\n        skipEmptyLines: true\n      });\n\n      const stocks: Stock[] = parsed.data.map((row: any) => ({\n        ticker: row.ticker,\n        startDate: row.start_date,\n        endDate: row.end_date || null\n      }));\n\n      return NextResponse.json({ stocks });\n    }\n\n    return NextResponse.json(\n      { error: 'Invalid action parameter' },\n      { status: 400 }\n    );\n\n  } catch (error) {\n    console.error('Error loading S&P 500 data:', error);\n    return NextResponse.json(\n      { error: 'Failed to load S&P 500 data' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Handle OPTIONS requests for CORS\n */\nexport async function OPTIONS(request: NextRequest) {\n  return new Response(null, {\n    status: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    },\n  });\n}\n\n/**\n * Utility function to load start-of-year dates\n */\nasync function loadStartOfYearDates(): Promise<{ [year: string]: string }> {\n  try {\n    const fs = require('fs');\n    const path = require('path');\n    const Papa = require('papaparse');\n\n    const csvPath = path.join(process.cwd(), 'data', 'start-of-year-dates.csv');\n    \n    if (!fs.existsSync(csvPath)) {\n      console.warn('Start-of-year dates file not found, using defaults');\n      return {};\n    }\n\n    const csvContent = fs.readFileSync(csvPath, 'utf8');\n    const parsed = Papa.parse(csvContent, {\n      header: true,\n      dynamicTyping: false,\n      skipEmptyLines: true\n    });\n\n    const dates: { [year: string]: string } = {};\n    \n    if (parsed.data && parsed.data.length > 0) {\n      const row = parsed.data[0];\n      for (const [year, dateStr] of Object.entries(row)) {\n        if (year !== 'Year' && typeof dateStr === 'string') {\n          // Convert from M/D/YY to YYYY-MM-DD format\n          if (dateStr.includes('/')) {\n            const [month, day, year2Digit] = dateStr.split('/');\n            const fullYear = parseInt(year2Digit) < 50 ? `20${year2Digit}` : `19${year2Digit}`;\n            dates[year] = `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n          }\n        }\n      }\n    }\n\n    return dates;\n  } catch (error) {\n    console.error('Error loading start-of-year dates:', error);\n    return {};\n  }\n}\n\n/**\n * Health check endpoint\n */\nexport async function HEAD(request: NextRequest) {\n  return new Response(null, {\n    status: 200,\n    headers: {\n      'Cache-Control': 'no-cache',\n    },\n  });\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}