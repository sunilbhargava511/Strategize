{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/lib/utils/dateUtils.ts"],"sourcesContent":["import { StartOfYearDates } from '../../types/backtesting';\n\n/**\n * Date utilities for portfolio backtesting\n */\n\nexport const START_OF_YEAR_DATES: StartOfYearDates = {\n  '1996': '1996-01-02',\n  '1997': '1997-01-07', \n  '1998': '1998-01-06',\n  '1999': '1999-01-05',\n  '2000': '2000-01-04',\n  '2001': '2001-01-02',\n  '2002': '2002-01-02',\n  '2003': '2003-01-07',\n  '2004': '2004-01-06',\n  '2005': '2005-01-04',\n  '2006': '2006-01-03',\n  '2007': '2007-01-03',\n  '2008': '2008-01-02',\n  '2009': '2009-01-06',\n  '2010': '2010-01-05',\n  '2011': '2011-01-04',\n  '2012': '2012-01-03',\n  '2013': '2013-01-02',\n  '2014': '2014-01-07',\n  '2015': '2015-01-06',\n  '2016': '2016-01-05',\n  '2017': '2017-01-03',\n  '2018': '2018-01-02',\n  '2019': '2019-01-02',\n  '2020': '2020-01-07',\n  '2021': '2021-01-05',\n  '2022': '2022-01-04',\n  '2023': '2023-01-03',\n  '2024': '2024-01-02',\n  '2025': '2025-01-07'\n};\n\n/**\n * Get the start-of-year date for a given year\n */\nexport function getStartOfYearDate(year: number): string {\n  const yearStr = year.toString();\n  const date = START_OF_YEAR_DATES[yearStr];\n  if (!date) {\n    throw new Error(`No start-of-year date found for year ${year}`);\n  }\n  return date;\n}\n\n/**\n * Format date for API calls (YYYY-MM-DD)\n */\nexport function formatDateForAPI(date: string | Date): string {\n  if (typeof date === 'string') {\n    // Assume it's already in the correct format or convert from M/D/YY\n    if (date.includes('/')) {\n      const [month, day, year] = date.split('/');\n      const fullYear = parseInt(year) < 50 ? `20${year}` : `19${year}`;\n      return `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n    }\n    return date;\n  }\n  \n  return date.toISOString().split('T')[0];\n}\n\n/**\n * Parse date from various formats to Date object\n */\nexport function parseDate(dateStr: string): Date {\n  // Handle M/D/YY format\n  if (dateStr.includes('/')) {\n    const [month, day, year] = dateStr.split('/');\n    const fullYear = parseInt(year) < 50 ? `20${year}` : `19${year}`;\n    return new Date(`${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`);\n  }\n  \n  // Handle YYYY-MM-DD format\n  return new Date(dateStr);\n}\n\n/**\n * Check if a date is within a given range\n */\nexport function isDateInRange(date: string, startDate: string, endDate: string | null): boolean {\n  const checkDate = parseDate(date);\n  const rangeStart = parseDate(startDate);\n  \n  if (endDate) {\n    const rangeEnd = parseDate(endDate);\n    return checkDate >= rangeStart && checkDate <= rangeEnd;\n  }\n  \n  return checkDate >= rangeStart;\n}\n\n/**\n * Get all years in a range\n */\nexport function getYearsInRange(startYear: number, endYear: number): number[] {\n  const years: number[] = [];\n  for (let year = startYear; year <= endYear; year++) {\n    years.push(year);\n  }\n  return years;\n}\n\n/**\n * Calculate years between two dates\n */\nexport function getYearsBetweenDates(startDate: string, endDate: string): number {\n  const start = parseDate(startDate);\n  const end = parseDate(endDate);\n  return (end.getTime() - start.getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n}\n\n/**\n * Check if a year has a start date defined\n */\nexport function hasStartOfYearDate(year: number): boolean {\n  return START_OF_YEAR_DATES[year.toString()] !== undefined;\n}\n\n/**\n * Get the next valid year with a start date\n */\nexport function getNextValidYear(year: number): number | null {\n  for (let nextYear = year + 1; nextYear <= 2025; nextYear++) {\n    if (hasStartOfYearDate(nextYear)) {\n      return nextYear;\n    }\n  }\n  return null;\n}\n\n/**\n * Convert date to display format\n */\nexport function formatDateForDisplay(date: string): string {\n  const dateObj = parseDate(date);\n  return dateObj.toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  });\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///Users/sunilbhargava/portfolio-backtesting-app/src/app/api/spy-data/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { SPYData } from '../../../types/backtesting';\nimport { getStartOfYearDate, getYearsInRange } from '../../../lib/utils/dateUtils';\n\n/**\n * SPY benchmark data API endpoint\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const startYear = parseInt(searchParams.get('startYear') || '2010');\n    const endYear = parseInt(searchParams.get('endYear') || '2024');\n\n    console.log(`ðŸ“ˆ Fetching SPY data from ${startYear} to ${endYear}`);\n\n    // Validate years\n    if (startYear < 1996 || endYear > 2025 || startYear >= endYear) {\n      return NextResponse.json(\n        { error: 'Invalid year range. Must be between 1996-2025 and startYear < endYear' },\n        { status: 400 }\n      );\n    }\n\n    const spyData: SPYData[] = [];\n    const years = getYearsInRange(startYear, endYear);\n    \n    // Get SPY data for each year\n    for (const year of years) {\n      try {\n        const yearDate = getStartOfYearDate(year);\n        \n        // Fetch SPY data using the market-cap API endpoint\n        const response = await fetch(\n          `${request.nextUrl.origin}/api/market-cap?ticker=SPY&date=${yearDate}`,\n          { \n            method: 'GET',\n            headers: { 'User-Agent': 'SPY-Data-Service/1.0' }\n          }\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          \n          if (data.price && data.adjusted_price) {\n            spyData.push({\n              date: data.date || yearDate,\n              price: data.price,\n              adjustedPrice: data.adjusted_price\n            });\n            \n            console.log(`âœ… SPY ${year}: $${data.adjusted_price.toFixed(2)}`);\n          } else {\n            console.warn(`âš ï¸  Incomplete SPY data for ${year}`);\n          }\n        } else {\n          console.warn(`âŒ Failed to fetch SPY data for ${year}: ${response.status}`);\n        }\n\n        // Add small delay to avoid overwhelming the API\n        await new Promise(resolve => setTimeout(resolve, 50));\n        \n      } catch (error) {\n        console.error(`Error fetching SPY data for ${year}:`, error);\n      }\n    }\n\n    if (spyData.length === 0) {\n      return NextResponse.json(\n        { error: 'No SPY data could be retrieved for the specified period' },\n        { status: 404 }\n      );\n    }\n\n    console.log(`ðŸ“Š Successfully retrieved SPY data for ${spyData.length} years`);\n\n    return NextResponse.json({\n      spyData,\n      startYear,\n      endYear,\n      dataPoints: spyData.length\n    });\n\n  } catch (error) {\n    console.error('SPY data API error:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch SPY data', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Handle POST requests for custom SPY data scenarios\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { dates, ticker = 'SPY' } = body;\n\n    if (!dates || !Array.isArray(dates)) {\n      return NextResponse.json(\n        { error: 'Dates array is required' },\n        { status: 400 }\n      );\n    }\n\n    console.log(`ðŸ“ˆ Fetching ${ticker} data for ${dates.length} custom dates`);\n\n    const spyData: SPYData[] = [];\n    \n    for (const date of dates) {\n      try {\n        const response = await fetch(\n          `${request.nextUrl.origin}/api/market-cap?ticker=${ticker}&date=${date}`,\n          { \n            method: 'GET',\n            headers: { 'User-Agent': 'SPY-Data-Service/1.0' }\n          }\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          \n          if (data.price && data.adjusted_price) {\n            spyData.push({\n              date: data.date || date,\n              price: data.price,\n              adjustedPrice: data.adjusted_price\n            });\n          }\n        }\n\n        // Rate limiting\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n      } catch (error) {\n        console.error(`Error fetching ${ticker} data for ${date}:`, error);\n      }\n    }\n\n    return NextResponse.json({\n      spyData,\n      ticker,\n      requestedDates: dates.length,\n      retrievedDates: spyData.length\n    });\n\n  } catch (error) {\n    console.error('Custom SPY data API error:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch custom SPY data' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Get SPY data for a specific date range with monthly intervals\n */\nexport async function PUT(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { startDate, endDate, interval = 'monthly', ticker = 'SPY' } = body;\n\n    if (!startDate || !endDate) {\n      return NextResponse.json(\n        { error: 'startDate and endDate are required' },\n        { status: 400 }\n      );\n    }\n\n    console.log(`ðŸ“ˆ Fetching ${ticker} data from ${startDate} to ${endDate} (${interval})`);\n\n    // Generate date array based on interval\n    const dates: string[] = [];\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    \n    if (interval === 'monthly') {\n      const current = new Date(start);\n      while (current <= end) {\n        dates.push(current.toISOString().split('T')[0]);\n        current.setMonth(current.getMonth() + 1);\n      }\n    } else if (interval === 'yearly') {\n      const current = new Date(start);\n      while (current <= end) {\n        dates.push(current.toISOString().split('T')[0]);\n        current.setFullYear(current.getFullYear() + 1);\n      }\n    } else {\n      return NextResponse.json(\n        { error: 'Invalid interval. Use \"monthly\" or \"yearly\"' },\n        { status: 400 }\n      );\n    }\n\n    const spyData: SPYData[] = [];\n    \n    for (const date of dates) {\n      try {\n        const response = await fetch(\n          `${request.nextUrl.origin}/api/market-cap?ticker=${ticker}&date=${date}`,\n          { \n            method: 'GET',\n            headers: { 'User-Agent': 'SPY-Data-Service/1.0' }\n          }\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          \n          if (data.price && data.adjusted_price) {\n            spyData.push({\n              date: data.date || date,\n              price: data.price,\n              adjustedPrice: data.adjusted_price\n            });\n          }\n        }\n\n        // Rate limiting\n        await new Promise(resolve => setTimeout(resolve, 150));\n        \n      } catch (error) {\n        console.error(`Error fetching ${ticker} data for ${date}:`, error);\n      }\n    }\n\n    return NextResponse.json({\n      spyData,\n      ticker,\n      startDate,\n      endDate,\n      interval,\n      requestedDates: dates.length,\n      retrievedDates: spyData.length\n    });\n\n  } catch (error) {\n    console.error('Interval SPY data API error:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch interval SPY data' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Handle OPTIONS requests for CORS\n */\nexport async function OPTIONS(request: NextRequest) {\n  return new Response(null, {\n    status: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    },\n  });\n}\n\n/**\n * Health check for SPY data service\n */\nexport async function HEAD(request: NextRequest) {\n  try {\n    // Test fetch of a single SPY data point to verify service health\n    const testDate = '2024-01-02';\n    const response = await fetch(\n      `${request.nextUrl.origin}/api/market-cap?ticker=SPY&date=${testDate}`,\n      { \n        method: 'GET',\n        headers: { 'User-Agent': 'SPY-Health-Check/1.0' }\n      }\n    );\n\n    if (response.ok) {\n      return new Response(null, {\n        status: 200,\n        headers: {\n          'X-Service-Status': 'healthy',\n          'Cache-Control': 'no-cache',\n        },\n      });\n    } else {\n      return new Response(null, {\n        status: 503,\n        headers: {\n          'X-Service-Status': 'degraded',\n          'Cache-Control': 'no-cache',\n        },\n      });\n    }\n  } catch (error) {\n    return new Response(null, {\n      status: 503,\n      headers: {\n        'X-Service-Status': 'unhealthy',\n        'Cache-Control': 'no-cache',\n      },\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}